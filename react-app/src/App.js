import { useState } from "react";
import CompModal from "./components/CompModal";
import Compsum from "./components/Compsum";


function App() {

  const [cnt, setCnt] = useState()
  const [arrComp, setArrComp] = useState(['1', '2', '3'])

  return (
    <>
      <h1>더하기문제</h1>
      <hr />
      {arrComp.map((v) => {
        return <Compsum key={v} />
      })}


      <CompModal cnt={cnt} />
    </>
  );
}

export default App;


//맵은 동일한 길이, 필터는 다른길이

//jsx에서 보간법, ``안에서의 ${}보간법 구분하기

//반복문을 넣어서 컴포넌트를 출력하는 경우에는 무조건 키를 넣어야함.키라는 프롭스가 필요. 키를 넣을 때는 모두 다 다른 유니크한 키값을 넣어야함.
//키의 출발 자체가 수정관리시에 그 키 하나만 수정하려고 하는거라서.
//오타가 있으면 오타만 찾아서지우면 되지 다 지울필요없으니까

//번호를 부여하는 것. 키가 바뀌면 새로 그려준다. 키는 이름이라고 보면됨. 키가 바뀌면 새로 그린다. 그래서 컴포넌트마다 다른 키값을 주어야함.
//유니크한 키값을 줘야한다(콘솔창에서 오류뜰때 그렇게 뜸)
//v는 같은 값이 나올 수 있음
//i는 반복되는 횟수. 0번째, 1번째, 2번째....
//key에 i를 주면 전부 다른 키가 들어갈수 있음??근데 이렇게 쓰면 안됨
//왜냐면 key가 변하면 해당 컴포넌트만 변해야함. 근데 내가 중간에서 특정 컴포넌트를 지울일이 생긴다고 가정했을때 배열의 개수가 줄어들면서 i값이 다바뀜 그래서 i를 사용하면 안됨. 배열이 삭제되거나 추가하면 i값도 달라지니까
//반면에 v는 변하지않음.배열안에잇는 값. 그 값은 변하지 않는다. 첫번째는 무조건 0
//키값=유니크한 이름.


//여기에 문제가 있음 목적:0이 변하면 0만그려야하는데 왜인지 0을 지울일이 생긴다고 가정해.그럼 i값이 하나씩 당겨지면서 전부다 키값이 하나씩오라ㅏ=가


//배열이 3개면 i는 3. 반복되는 횟수